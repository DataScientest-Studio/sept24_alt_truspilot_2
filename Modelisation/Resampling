#!/usr/bin/env python3
"""
resempling_simple.py â€” Resampling simple pour Ã©quilibrer les classes

BUT
----
Prendre un CSV prÃ©processÃ© et Ã©quilibrer les classes de maniÃ¨re simple,
sans librairies complexes, juste avec pandas et numpy.
"""

import argparse
import pandas as pd
import numpy as np
from pathlib import Path
import sys

def simple_undersample(df, target_col, min_samples=None):
    """
    Sous-Ã©chantillonnage simple : rÃ©duire la classe majoritaire
    
    Args:
        df: DataFrame avec les donnÃ©es
        target_col: nom de la colonne cible
        min_samples: nombre minimum d'Ã©chantillons par classe (optionnel)
    
    Returns:
        DataFrame Ã©quilibrÃ©
    """
    print("ðŸ”„ Sous-Ã©chantillonnage simple...")
    
    # Compter les Ã©chantillons par classe
    class_counts = df[target_col].value_counts()
    print(f"ðŸ“Š Distribution avant Ã©quilibrage:")
    for class_name, count in class_counts.items():
        print(f"   Classe {class_name}: {count} Ã©chantillons")
    
    # DÃ©terminer le nombre cible
    if min_samples is None:
        # Prendre la classe la plus petite comme rÃ©fÃ©rence
        min_samples = class_counts.min()
    
    print(f"ðŸŽ¯ Objectif: {min_samples} Ã©chantillons par classe")
    
    # Ã‰quilibrer chaque classe
    balanced_dfs = []
    for class_name in class_counts.index:
        class_df = df[df[target_col] == class_name]
        
        if len(class_df) > min_samples:
            # Sous-Ã©chantillonner
            sampled_df = class_df.sample(n=min_samples, random_state=42)
            print(f"   Classe {class_name}: {len(class_df)} â†’ {len(sampled_df)} Ã©chantillons")
        else:
            # Garder tous les Ã©chantillons
            sampled_df = class_df
            print(f"   Classe {class_name}: {len(class_df)} Ã©chantillons (conservÃ©s)")
        
        balanced_dfs.append(sampled_df)
    
    # Combiner tous les DataFrames
    balanced_df = pd.concat(balanced_dfs, ignore_index=True)
    
    # MÃ©langer les donnÃ©es
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)
    
    print(f"âœ… RÃ©sultat: {len(balanced_df)} Ã©chantillons au total")
    
    return balanced_df

def simple_oversample(df, target_col, max_samples=None):
    """
    Sur-Ã©chantillonnage simple : augmenter la classe minoritaire
    
    Args:
        df: DataFrame avec les donnÃ©es
        target_col: nom de la colonne cible
        max_samples: nombre maximum d'Ã©chantillons par classe (optionnel)
    
    Returns:
        DataFrame Ã©quilibrÃ©
    """
    print("ðŸ”„ Sur-Ã©chantillonnage simple...")
    
    # Compter les Ã©chantillons par classe
    class_counts = df[target_col].value_counts()
    print(f"ðŸ“Š Distribution avant Ã©quilibrage:")
    for class_name, count in class_counts.items():
        print(f"   Classe {class_name}: {count} Ã©chantillons")
    
    # DÃ©terminer le nombre cible
    if max_samples is None:
        # Prendre la classe la plus grande comme rÃ©fÃ©rence
        max_samples = class_counts.max()
    
    print(f"ðŸŽ¯ Objectif: {max_samples} Ã©chantillons par classe")
    
    # Ã‰quilibrer chaque classe
    balanced_dfs = []
    for class_name in class_counts.index:
        class_df = df[df[target_col] == class_name]
        
        if len(class_df) < max_samples:
            # Sur-Ã©chantillonner (rÃ©pÃ©ter les Ã©chantillons)
            n_samples_needed = max_samples - len(class_df)
            
            # Dupliquer les Ã©chantillons existants
            extra_samples = class_df.sample(n=n_samples_needed, replace=True, random_state=42)
            
            # Combiner original + extra
            oversampled_df = pd.concat([class_df, extra_samples], ignore_index=True)
            print(f"   Classe {class_name}: {len(class_df)} â†’ {len(oversampled_df)} Ã©chantillons")
        else:
            # Garder tous les Ã©chantillons
            oversampled_df = class_df
            print(f"   Classe {class_name}: {len(class_df)} Ã©chantillons (conservÃ©s)")
        
        balanced_dfs.append(oversampled_df)
    
    # Combiner tous les DataFrames
    balanced_df = pd.concat(balanced_dfs, ignore_index=True)
    
    # MÃ©langer les donnÃ©es
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)
    
    print(f"âœ… RÃ©sultat: {len(balanced_df)} Ã©chantillons au total")
    
    return balanced_df

def main(input_file, output_file, target_col, method='undersample', samples_per_class=None):
    """
    Fonction principale de resampling
    
    Args:
        input_file: fichier CSV d'entrÃ©e (prÃ©processÃ©)
        output_file: fichier CSV de sortie
        target_col: colonne cible Ã  Ã©quilibrer
        method: 'undersample' ou 'oversample'
        samples_per_class: nombre d'Ã©chantillons par classe (optionnel)
    """
    
    # VÃ©rifier que le fichier existe
    if not Path(input_file).exists():
        print(f"âŒ Fichier introuvable : {input_file}")
        sys.exit(1)
    
    # Charger les donnÃ©es
    print(f"ðŸ“‚ Chargement du fichier: {input_file}")
    df = pd.read_csv(input_file)
    print(f"ðŸ“Š DonnÃ©es chargÃ©es: {len(df)} lignes, {len(df.columns)} colonnes")
    
    # VÃ©rifier que la colonne cible existe
    if target_col not in df.columns:
        print(f"âŒ Colonne '{target_col}' absente. Colonnes disponibles : {list(df.columns)}")
        sys.exit(1)
    
    # Supprimer les lignes avec valeurs manquantes dans la colonne cible
    df_clean = df.dropna(subset=[target_col])
    print(f"ðŸ§¹ AprÃ¨s nettoyage: {len(df_clean)} lignes (suppression des valeurs manquantes)")
    
    # Appliquer le resampling
    if method == 'undersample':
        balanced_df = simple_undersample(df_clean, target_col, samples_per_class)
    elif method == 'oversample':
        balanced_df = simple_oversample(df_clean, target_col, samples_per_class)
    else:
        print(f"âŒ MÃ©thode inconnue: {method}. Utilisez 'undersample' ou 'oversample'")
        sys.exit(1)
    
    # Sauvegarder le rÃ©sultat
    balanced_df.to_csv(output_file, index=False)
    print(f"ðŸ’¾ Fichier sauvegardÃ©: {output_file}")
    
    # AperÃ§u du rÃ©sultat
    print("\nðŸ”Ž AperÃ§u des donnÃ©es Ã©quilibrÃ©es:")
    print(balanced_df[target_col].value_counts().sort_index())
    
    print("\nðŸ“‹ AperÃ§u du contenu:")
    print(balanced_df.head())

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Resampling simple pour Ã©quilibrer les classes")
    
    parser.add_argument("--input", type=str, default="trustpilot_dataset_final_cleaned_simple.csv",
                       help="Fichier CSV d'entrÃ©e (prÃ©processÃ©)")
    parser.add_argument("--output", type=str, default="trustpilot_balanced.csv",
                       help="Fichier CSV de sortie")
    parser.add_argument("--target-col", type=str, default="Rating",
                       help="Nom de la colonne cible Ã  Ã©quilibrer")
    parser.add_argument("--method", type=str, choices=["undersample", "oversample"], default="undersample",
                       help="MÃ©thode de resampling")
    parser.add_argument("--samples", type=int, default=None,
                       help="Nombre d'Ã©chantillons par classe (optionnel)")
    
    args = parser.parse_args()
    
    main(
        input_file=args.input,
        output_file=args.output,
        target_col=args.target_col,
        method=args.method,
        samples_per_class=args.samples
    )
